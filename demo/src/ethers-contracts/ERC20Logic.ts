/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type TransferDataStruct = {
  token: PromiseOrValue<string>;
  payload: PromiseOrValue<BytesLike>;
  partition: PromiseOrValue<BytesLike>;
  operator: PromiseOrValue<string>;
  from: PromiseOrValue<string>;
  to: PromiseOrValue<string>;
  value: PromiseOrValue<BigNumberish>;
  tokenId: PromiseOrValue<BigNumberish>;
  data: PromiseOrValue<BytesLike>;
  operatorData: PromiseOrValue<BytesLike>;
};

export type TransferDataStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  string,
  string
] & {
  token: string;
  payload: string;
  partition: string;
  operator: string;
  from: string;
  to: string;
  value: BigNumber;
  tokenId: BigNumber;
  data: string;
  operatorData: string;
};

export interface ERC20LogicInterface extends utils.Interface {
  functions: {
    "addController(address)": FunctionFragment;
    "addMinter(address)": FunctionFragment;
    "addRole(address,bytes32)": FunctionFragment;
    "allowance(address,address)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "changeManager(address)": FunctionFragment;
    "decimals()": FunctionFragment;
    "hasRole(address,bytes32)": FunctionFragment;
    "initialize(bytes)": FunctionFragment;
    "isController(address)": FunctionFragment;
    "isMinter(address)": FunctionFragment;
    "manager()": FunctionFragment;
    "name()": FunctionFragment;
    "on(bytes32,function)": FunctionFragment;
    "owner()": FunctionFragment;
    "removeController(address)": FunctionFragment;
    "removeMinter(address)": FunctionFragment;
    "removeRole(address,bytes32)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "symbol()": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "mint(address,uint256)": FunctionFragment;
    "burn(uint256)": FunctionFragment;
    "burnFrom(address,uint256)": FunctionFragment;
    "tokenTransfer((address,bytes,bytes32,address,address,address,uint256,uint256,bytes,bytes))": FunctionFragment;
    "tokenStandard()": FunctionFragment;
    "transfer(address,uint256)": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "increaseAllowance(address,uint256)": FunctionFragment;
    "decreaseAllowance(address,uint256)": FunctionFragment;
    "mintingAllowed()": FunctionFragment;
    "burningAllowed()": FunctionFragment;
    "maxSupply()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addController"
      | "addMinter"
      | "addRole"
      | "allowance"
      | "balanceOf"
      | "canImplementInterfaceForAddress"
      | "changeManager"
      | "decimals"
      | "hasRole"
      | "initialize"
      | "isController"
      | "isMinter"
      | "manager"
      | "name"
      | "on"
      | "owner"
      | "removeController"
      | "removeMinter"
      | "removeRole"
      | "renounceOwnership"
      | "symbol"
      | "totalSupply"
      | "transferOwnership"
      | "mint"
      | "burn"
      | "burnFrom"
      | "tokenTransfer"
      | "tokenStandard"
      | "transfer"
      | "transferFrom"
      | "approve"
      | "increaseAllowance"
      | "decreaseAllowance"
      | "mintingAllowed"
      | "burningAllowed"
      | "maxSupply"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "manager", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "on",
    values: [PromiseOrValue<BytesLike>, any]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "removeController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "burn",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "burnFrom",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenTransfer",
    values: [TransferDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenStandard",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseAllowance",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "decreaseAllowance",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "mintingAllowed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "burningAllowed",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "maxSupply", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "addController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "manager", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "on", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "removeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burnFrom", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenStandard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decreaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintingAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burningAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "maxSupply", data: BytesLike): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "Approval(address,address,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RoleAdded(address,bytes32)": EventFragment;
    "RoleRemoved(address,bytes32)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  value: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface RoleAddedEventObject {
  caller: string;
  roleId: string;
}
export type RoleAddedEvent = TypedEvent<[string, string], RoleAddedEventObject>;

export type RoleAddedEventFilter = TypedEventFilter<RoleAddedEvent>;

export interface RoleRemovedEventObject {
  caller: string;
  roleId: string;
}
export type RoleRemovedEvent = TypedEvent<
  [string, string],
  RoleRemovedEventObject
>;

export type RoleRemovedEventFilter = TypedEventFilter<RoleRemovedEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  value: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface ERC20Logic extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ERC20LogicInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<[number]>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * This function can only be invoked if the uint256 value in the UPGRADING_FLAG_SLOT storage slot is non-zero and matches the length of the data provided
     * This cannot be invoked directly. It must be invoked by a TokenProxy inside of upgradeTo or in the consturctor.
     * @param data The data to initalize with
     */
    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Listen for an event hash and invoke a given callback function. This callback function will be invoked with the TransferData for the event as well as the current caller that trigger the event appended to the end of the calldata. This can usually be accessed using _msgSender()
     * Can not be used directly, can only be used by enabled and registered extensions
     */
    on(
      eventId: PromiseOrValue<BytesLike>,
      callback: any,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Mints `amount` tokens and sends to `to` address. Only an address with the Minter role can invoke this function
     * @param amount The amount of tokens to be minted
     * @param to The recipient of the minted tokens
     */
    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Destroys `amount` tokens from the caller. See {ERC20-_burn}.
     * @param amount The amount of tokens to burn
     */
    burn(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`.
     * @param account The account to burn from
     * @param amount The amount of tokens to burn
     */
    burnFrom(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tokenTransfer(
      td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * This will always return {TokenStandard.ERC20}
     */
    tokenStandard(overrides?: CallOverrides): Promise<[number]>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the transfer
     */
    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the tokens
     * @param sender The sender of tokens
     */
    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if minting is allowed on this token, otherwise false
     */
    mintingAllowed(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns true if burning is allowed on this token, otherwise false
     */
    burningAllowed(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns the maximum value the totalSupply() can be for this token
     */
    maxSupply(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  /**
   * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
   * @param caller The address to grant the Controller role to
   */
  addController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
   * @param caller The address to grant the Minter role to
   */
  addMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
   * @param caller The address to add the roleId to
   * @param roleId The role ID to assign to the caller address
   */
  addRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-allowance}.
   */
  allowance(
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC20-balanceOf}.
   */
  balanceOf(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
   * @param addr Address for which the contract will implement the interface
   * @param interfaceHash keccak256 hash of the name of the interface
   */
  canImplementInterfaceForAddress(
    interfaceHash: PromiseOrValue<BytesLike>,
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
   * Change the current token manager. Only the current token manager can set a new token manager.
   */
  changeManager(
    newManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
   */
  decimals(overrides?: CallOverrides): Promise<number>;

  hasRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * This function can only be invoked if the uint256 value in the UPGRADING_FLAG_SLOT storage slot is non-zero and matches the length of the data provided
   * This cannot be invoked directly. It must be invoked by a TokenProxy inside of upgradeTo or in the consturctor.
   * @param data The data to initalize with
   */
  initialize(
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if `caller` has the Controller role granted
   */
  isController(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns true if `caller` has the Minter role granted
   */
  isMinter(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns the current token manager
   */
  manager(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the name of the token.
   */
  name(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
   * @param caller The address to remove the Controller role from
   */
  removeController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
   * @param caller The address to remove the Minter role from
   */
  removeMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
   * @param caller The address to remove the roleId from
   * @param roleId The role ID to remove from the caller address
   */
  removeRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the symbol of the token, usually a shorter version of the name.
   */
  symbol(overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC20-totalSupply}.
   */
  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
   * @param newOwner The address of the new owner
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Mints `amount` tokens and sends to `to` address. Only an address with the Minter role can invoke this function
   * @param amount The amount of tokens to be minted
   * @param to The recipient of the minted tokens
   */
  mint(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Destroys `amount` tokens from the caller. See {ERC20-_burn}.
   * @param amount The amount of tokens to burn
   */
  burn(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`.
   * @param account The account to burn from
   * @param amount The amount of tokens to burn
   */
  burnFrom(
    account: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tokenTransfer(
    td: TransferDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * This will always return {TokenStandard.ERC20}
   */
  tokenStandard(overrides?: CallOverrides): Promise<number>;

  /**
   * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
   * @param amount The amount of tokens to transfer
   * @param recipient The recipient of the transfer
   */
  transfer(
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
   * @param amount The amount of tokens to transfer
   * @param recipient The recipient of the tokens
   * @param sender The sender of tokens
   */
  transferFrom(
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.
   */
  approve(
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
   */
  increaseAllowance(
    spender: PromiseOrValue<string>,
    addedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
   */
  decreaseAllowance(
    spender: PromiseOrValue<string>,
    subtractedValue: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if minting is allowed on this token, otherwise false
   */
  mintingAllowed(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns true if burning is allowed on this token, otherwise false
   */
  burningAllowed(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the maximum value the totalSupply() can be for this token
   */
  maxSupply(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<number>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * This function can only be invoked if the uint256 value in the UPGRADING_FLAG_SLOT storage slot is non-zero and matches the length of the data provided
     * This cannot be invoked directly. It must be invoked by a TokenProxy inside of upgradeTo or in the consturctor.
     * @param data The data to initalize with
     */
    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<string>;

    /**
     * Listen for an event hash and invoke a given callback function. This callback function will be invoked with the TransferData for the event as well as the current caller that trigger the event appended to the end of the calldata. This can usually be accessed using _msgSender()
     * Can not be used directly, can only be used by enabled and registered extensions
     */
    on(
      eventId: PromiseOrValue<BytesLike>,
      callback: any,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mints `amount` tokens and sends to `to` address. Only an address with the Minter role can invoke this function
     * @param amount The amount of tokens to be minted
     * @param to The recipient of the minted tokens
     */
    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Destroys `amount` tokens from the caller. See {ERC20-_burn}.
     * @param amount The amount of tokens to burn
     */
    burn(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`.
     * @param account The account to burn from
     * @param amount The amount of tokens to burn
     */
    burnFrom(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tokenTransfer(
      td: TransferDataStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * This will always return {TokenStandard.ERC20}
     */
    tokenStandard(overrides?: CallOverrides): Promise<number>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the transfer
     */
    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the tokens
     * @param sender The sender of tokens
     */
    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if minting is allowed on this token, otherwise false
     */
    mintingAllowed(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns true if burning is allowed on this token, otherwise false
     */
    burningAllowed(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the maximum value the totalSupply() can be for this token
     */
    maxSupply(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      value?: null
    ): ApprovalEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "RoleAdded(address,bytes32)"(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleAddedEventFilter;
    RoleAdded(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleAddedEventFilter;

    "RoleRemoved(address,bytes32)"(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleRemovedEventFilter;
    RoleRemoved(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleRemovedEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      value?: null
    ): TransferEventFilter;
  };

  estimateGas: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This function can only be invoked if the uint256 value in the UPGRADING_FLAG_SLOT storage slot is non-zero and matches the length of the data provided
     * This cannot be invoked directly. It must be invoked by a TokenProxy inside of upgradeTo or in the consturctor.
     * @param data The data to initalize with
     */
    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Listen for an event hash and invoke a given callback function. This callback function will be invoked with the TransferData for the event as well as the current caller that trigger the event appended to the end of the calldata. This can usually be accessed using _msgSender()
     * Can not be used directly, can only be used by enabled and registered extensions
     */
    on(
      eventId: PromiseOrValue<BytesLike>,
      callback: any,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Mints `amount` tokens and sends to `to` address. Only an address with the Minter role can invoke this function
     * @param amount The amount of tokens to be minted
     * @param to The recipient of the minted tokens
     */
    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Destroys `amount` tokens from the caller. See {ERC20-_burn}.
     * @param amount The amount of tokens to burn
     */
    burn(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`.
     * @param account The account to burn from
     * @param amount The amount of tokens to burn
     */
    burnFrom(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tokenTransfer(
      td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * This will always return {TokenStandard.ERC20}
     */
    tokenStandard(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the transfer
     */
    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the tokens
     * @param sender The sender of tokens
     */
    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Returns true if minting is allowed on this token, otherwise false
     */
    mintingAllowed(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns true if burning is allowed on this token, otherwise false
     */
    burningAllowed(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the maximum value the totalSupply() can be for this token
     */
    maxSupply(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This function can only be invoked if the uint256 value in the UPGRADING_FLAG_SLOT storage slot is non-zero and matches the length of the data provided
     * This cannot be invoked directly. It must be invoked by a TokenProxy inside of upgradeTo or in the consturctor.
     * @param data The data to initalize with
     */
    initialize(
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Listen for an event hash and invoke a given callback function. This callback function will be invoked with the TransferData for the event as well as the current caller that trigger the event appended to the end of the calldata. This can usually be accessed using _msgSender()
     * Can not be used directly, can only be used by enabled and registered extensions
     */
    on(
      eventId: PromiseOrValue<BytesLike>,
      callback: any,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Mints `amount` tokens and sends to `to` address. Only an address with the Minter role can invoke this function
     * @param amount The amount of tokens to be minted
     * @param to The recipient of the minted tokens
     */
    mint(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Destroys `amount` tokens from the caller. See {ERC20-_burn}.
     * @param amount The amount of tokens to burn
     */
    burn(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`.
     * @param account The account to burn from
     * @param amount The amount of tokens to burn
     */
    burnFrom(
      account: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tokenTransfer(
      td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This will always return {TokenStandard.ERC20}
     */
    tokenStandard(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the transfer
     */
    transfer(
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     * @param amount The amount of tokens to transfer
     * @param recipient The recipient of the tokens
     * @param sender The sender of tokens
     */
    transferFrom(
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: PromiseOrValue<string>,
      addedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: PromiseOrValue<string>,
      subtractedValue: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if minting is allowed on this token, otherwise false
     */
    mintingAllowed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns true if burning is allowed on this token, otherwise false
     */
    burningAllowed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the maximum value the totalSupply() can be for this token
     */
    maxSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
