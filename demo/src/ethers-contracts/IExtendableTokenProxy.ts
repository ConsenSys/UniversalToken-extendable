/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type TransferDataStruct = {
  token: PromiseOrValue<string>;
  payload: PromiseOrValue<BytesLike>;
  partition: PromiseOrValue<BytesLike>;
  operator: PromiseOrValue<string>;
  from: PromiseOrValue<string>;
  to: PromiseOrValue<string>;
  value: PromiseOrValue<BigNumberish>;
  tokenId: PromiseOrValue<BigNumberish>;
  data: PromiseOrValue<BytesLike>;
  operatorData: PromiseOrValue<BytesLike>;
};

export type TransferDataStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  string,
  string
] & {
  token: string;
  payload: string;
  partition: string;
  operator: string;
  from: string;
  to: string;
  value: BigNumber;
  tokenId: BigNumber;
  data: string;
  operatorData: string;
};

export interface IExtendableTokenProxyInterface extends utils.Interface {
  functions: {
    "addController(address)": FunctionFragment;
    "addMinter(address)": FunctionFragment;
    "changeManager(address)": FunctionFragment;
    "domainName()": FunctionFragment;
    "domainSeparator()": FunctionFragment;
    "domainVersion()": FunctionFragment;
    "generateDomainSeparator()": FunctionFragment;
    "isController(address)": FunctionFragment;
    "isMinter(address)": FunctionFragment;
    "manager()": FunctionFragment;
    "owner()": FunctionFragment;
    "removeController(address)": FunctionFragment;
    "removeMinter(address)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "tokenStandard()": FunctionFragment;
    "tokenTransfer((address,bytes,bytes32,address,address,address,uint256,uint256,bytes,bytes))": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "upgradeTo(address,bytes)": FunctionFragment;
    "registerExtension(address)": FunctionFragment;
    "upgradeExtension(address,address)": FunctionFragment;
    "removeExtension(address)": FunctionFragment;
    "disableExtension(address)": FunctionFragment;
    "enableExtension(address)": FunctionFragment;
    "allExtensionsRegistered()": FunctionFragment;
    "allExtensionProxies()": FunctionFragment;
    "proxyAddressForExtension(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addController"
      | "addMinter"
      | "changeManager"
      | "domainName"
      | "domainSeparator"
      | "domainVersion"
      | "generateDomainSeparator"
      | "isController"
      | "isMinter"
      | "manager"
      | "owner"
      | "removeController"
      | "removeMinter"
      | "renounceOwnership"
      | "tokenStandard"
      | "tokenTransfer"
      | "transferOwnership"
      | "upgradeTo"
      | "registerExtension"
      | "upgradeExtension"
      | "removeExtension"
      | "disableExtension"
      | "enableExtension"
      | "allExtensionsRegistered"
      | "allExtensionProxies"
      | "proxyAddressForExtension"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "domainName",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "generateDomainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "manager", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "removeController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenStandard",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenTransfer",
    values: [TransferDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeExtension",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "disableExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enableExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "allExtensionsRegistered",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allExtensionProxies",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proxyAddressForExtension",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "addController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addMinter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "domainName", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "generateDomainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "manager", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenStandard",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allExtensionsRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allExtensionProxies",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxyAddressForExtension",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IExtendableTokenProxy extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IExtendableTokenProxyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * The current version for this contract. Changing this value will cause the domain separator to update and trigger a cache update.
     */
    domainVersion(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<[string]>;

    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    manager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<[number]>;

    tokenTransfer(
      transfer: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Register the extension at the given global extension address. This will deploy a new ExtensionProxy contract to act as a proxy. The extension's proxy will be initalized and all functions the extension has will be registered
     * @param extension The deployed extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<[string[]]>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<[string[]]>;

    /**
     * Get the deployed extension proxy address given a global extension address. This function assumes the given global extension address has been registered using  _registerExtension.
     * @param extension The global extension address to convert
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;
  };

  addController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeManager(
    newManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Uses _domainName()
   * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
   */
  domainName(overrides?: CallOverrides): Promise<string>;

  /**
   * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
   * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
   */
  domainSeparator(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * The current version for this contract. Changing this value will cause the domain separator to update and trigger a cache update.
   */
  domainVersion(overrides?: CallOverrides): Promise<string>;

  /**
   * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
   */
  generateDomainSeparator(overrides?: CallOverrides): Promise<string>;

  isController(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isMinter(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  manager(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  removeController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
   */
  tokenStandard(overrides?: CallOverrides): Promise<number>;

  tokenTransfer(
    transfer: TransferDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    logic: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Register the extension at the given global extension address. This will deploy a new ExtensionProxy contract to act as a proxy. The extension's proxy will be initalized and all functions the extension has will be registered
   * @param extension The deployed extension address to register
   */
  registerExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
   * @param extension The global extension address to upgrade
   * @param newExtension The new global extension address to upgrade the extension to
   */
  upgradeExtension(
    extension: PromiseOrValue<string>,
    newExtension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
   * @param extension Either the global extension address or the deployed extension proxy address to remove
   */
  removeExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
   * @param extension Either the global extension address or the deployed extension proxy address to disable
   */
  disableExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
   * @param extension Either the global extension address or the deployed extension proxy address to enable
   */
  enableExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
   */
  allExtensionsRegistered(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
   */
  allExtensionProxies(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Get the deployed extension proxy address given a global extension address. This function assumes the given global extension address has been registered using  _registerExtension.
   * @param extension The global extension address to convert
   */
  proxyAddressForExtension(
    extension: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    addController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<string>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(overrides?: CallOverrides): Promise<string>;

    /**
     * The current version for this contract. Changing this value will cause the domain separator to update and trigger a cache update.
     */
    domainVersion(overrides?: CallOverrides): Promise<string>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<string>;

    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    manager(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    removeController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<number>;

    tokenTransfer(
      transfer: TransferDataStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Register the extension at the given global extension address. This will deploy a new ExtensionProxy contract to act as a proxy. The extension's proxy will be initalized and all functions the extension has will be registered
     * @param extension The deployed extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Get the deployed extension proxy address given a global extension address. This function assumes the given global extension address has been registered using  _registerExtension.
     * @param extension The global extension address to convert
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {};

  estimateGas: {
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * The current version for this contract. Changing this value will cause the domain separator to update and trigger a cache update.
     */
    domainVersion(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    manager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<BigNumber>;

    tokenTransfer(
      transfer: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Register the extension at the given global extension address. This will deploy a new ExtensionProxy contract to act as a proxy. The extension's proxy will be initalized and all functions the extension has will be registered
     * @param extension The deployed extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the deployed extension proxy address given a global extension address. This function assumes the given global extension address has been registered using  _registerExtension.
     * @param extension The global extension address to convert
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The current version for this contract. Changing this value will cause the domain separator to update and trigger a cache update.
     */
    domainVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tokenTransfer(
      transfer: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Register the extension at the given global extension address. This will deploy a new ExtensionProxy contract to act as a proxy. The extension's proxy will be initalized and all functions the extension has will be registered
     * @param extension The deployed extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionsRegistered(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled
     */
    allExtensionProxies(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the deployed extension proxy address given a global extension address. This function assumes the given global extension address has been registered using  _registerExtension.
     * @param extension The global extension address to convert
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
