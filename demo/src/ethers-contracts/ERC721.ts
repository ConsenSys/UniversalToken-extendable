/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type TransferDataStruct = {
  token: PromiseOrValue<string>;
  payload: PromiseOrValue<BytesLike>;
  partition: PromiseOrValue<BytesLike>;
  operator: PromiseOrValue<string>;
  from: PromiseOrValue<string>;
  to: PromiseOrValue<string>;
  value: PromiseOrValue<BigNumberish>;
  tokenId: PromiseOrValue<BigNumberish>;
  data: PromiseOrValue<BytesLike>;
  operatorData: PromiseOrValue<BytesLike>;
};

export type TransferDataStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  string,
  string
] & {
  token: string;
  payload: string;
  partition: string;
  operator: string;
  from: string;
  to: string;
  value: BigNumber;
  tokenId: BigNumber;
  data: string;
  operatorData: string;
};

export interface ERC721Interface extends utils.Interface {
  functions: {
    "addController(address)": FunctionFragment;
    "addMinter(address)": FunctionFragment;
    "addRole(address,bytes32)": FunctionFragment;
    "allExtensionProxies()": FunctionFragment;
    "allExtensionsRegistered()": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "changeManager(address)": FunctionFragment;
    "disableExtension(address)": FunctionFragment;
    "domainName()": FunctionFragment;
    "domainSeparator()": FunctionFragment;
    "domainVersion()": FunctionFragment;
    "enableExtension(address)": FunctionFragment;
    "generateDomainSeparator()": FunctionFragment;
    "hasRole(address,bytes32)": FunctionFragment;
    "isController(address)": FunctionFragment;
    "isMinter(address)": FunctionFragment;
    "manager()": FunctionFragment;
    "owner()": FunctionFragment;
    "proxyAddressForExtension(address)": FunctionFragment;
    "registerExtension(address)": FunctionFragment;
    "removeController(address)": FunctionFragment;
    "removeExtension(address)": FunctionFragment;
    "removeMinter(address)": FunctionFragment;
    "removeRole(address,bytes32)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "tokenTransfer((address,bytes,bytes32,address,address,address,uint256,uint256,bytes,bytes))": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "upgradeExtension(address,address)": FunctionFragment;
    "upgradeTo(address,bytes)": FunctionFragment;
    "tokenStandard()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addController"
      | "addMinter"
      | "addRole"
      | "allExtensionProxies"
      | "allExtensionsRegistered"
      | "canImplementInterfaceForAddress"
      | "changeManager"
      | "disableExtension"
      | "domainName"
      | "domainSeparator"
      | "domainVersion"
      | "enableExtension"
      | "generateDomainSeparator"
      | "hasRole"
      | "isController"
      | "isMinter"
      | "manager"
      | "owner"
      | "proxyAddressForExtension"
      | "registerExtension"
      | "removeController"
      | "removeExtension"
      | "removeMinter"
      | "removeRole"
      | "renounceOwnership"
      | "tokenTransfer"
      | "transferOwnership"
      | "upgradeExtension"
      | "upgradeTo"
      | "tokenStandard"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "allExtensionProxies",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allExtensionsRegistered",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "disableExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "domainName",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "domainVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enableExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "generateDomainSeparator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "manager", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxyAddressForExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "registerExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeController",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeExtension",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeRole",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenTransfer",
    values: [TransferDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeExtension",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenStandard",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "addController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "allExtensionProxies",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "allExtensionsRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "domainName", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "domainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "domainVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "generateDomainSeparator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isMinter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "manager", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxyAddressForExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "removeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenStandard",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "ExtensionUpgraded(address,address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RoleAdded(address,bytes32)": EventFragment;
    "RoleRemoved(address,bytes32)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface ExtensionUpgradedEventObject {
  extension: string;
  newExtension: string;
}
export type ExtensionUpgradedEvent = TypedEvent<
  [string, string],
  ExtensionUpgradedEventObject
>;

export type ExtensionUpgradedEventFilter =
  TypedEventFilter<ExtensionUpgradedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface RoleAddedEventObject {
  caller: string;
  roleId: string;
}
export type RoleAddedEvent = TypedEvent<[string, string], RoleAddedEventObject>;

export type RoleAddedEventFilter = TypedEventFilter<RoleAddedEvent>;

export interface RoleRemovedEventObject {
  caller: string;
  roleId: string;
}
export type RoleRemovedEvent = TypedEvent<
  [string, string],
  RoleRemovedEventObject
>;

export type RoleRemovedEventFilter = TypedEventFilter<RoleRemovedEvent>;

export interface UpgradedEventObject {
  logic: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface ERC721 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ERC721Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled. You can use these addresses for direct interaction. Remember you can also interact with extensions through the TokenProxy.
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<[string[]]>;

    /**
     * Return an array of all global extension addresses, regardless of if they are enabled or disabled. You cannot interact with these addresses. For user interaction you should use ExtendableTokenProxy.allExtensionProxies
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<[string[]]>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<[string]>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Uses _domainName()
     * The current version for this contract. This is the domain version used in the domain seperator
     */
    domainVersion(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<[string]>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Return the deployed extension proxy address given a global extension address. This function reverts if the given global extension has not been registered using registerExtension
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Register an extension providing the given global extension address. This will deploy a new ExtensionProxy contract to act as the extension proxy and register all function selectors the extension exposes. This will also invoke the initialize function on the extension proxy. Registering an extension automatically enables it for use. Registering an extension automatically grants any roles the extension requires to the address of the deployed extension proxy. See: IExtensionMetadata.requiredRoles()
     * @param extension The global extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tokenTransfer(
      _td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the TokenProxy logic contract. Can only be executed by the current manager address
     * Perform an upgrade on the proxy and replace the current logic contract with a new one. You must provide the new address of the logic contract and (optionally) some arbitrary data to pass to the logic contract's initialize function.
     * @param data Any arbitrary data, will be passed to the new logic contract's initialize function
     * @param logic The address of the new logic contract
     */
    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<[number]>;
  };

  /**
   * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
   * @param caller The address to grant the Controller role to
   */
  addController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
   * @param caller The address to grant the Minter role to
   */
  addMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
   * @param caller The address to add the roleId to
   * @param roleId The role ID to assign to the caller address
   */
  addRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled. You can use these addresses for direct interaction. Remember you can also interact with extensions through the TokenProxy.
   */
  allExtensionProxies(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Return an array of all global extension addresses, regardless of if they are enabled or disabled. You cannot interact with these addresses. For user interaction you should use ExtendableTokenProxy.allExtensionProxies
   */
  allExtensionsRegistered(overrides?: CallOverrides): Promise<string[]>;

  /**
   * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
   * @param addr Address for which the contract will implement the interface
   * @param interfaceHash keccak256 hash of the name of the interface
   */
  canImplementInterfaceForAddress(
    interfaceHash: PromiseOrValue<BytesLike>,
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
   * Change the current token manager. Only the current token manager can set a new token manager.
   */
  changeManager(
    newManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
   * @param extension Either the global extension address or the deployed extension proxy address to disable
   */
  disableExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Uses _domainName()
   * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
   */
  domainName(overrides?: CallOverrides): Promise<string>;

  /**
   * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
   * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
   */
  domainSeparator(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Uses _domainName()
   * The current version for this contract. This is the domain version used in the domain seperator
   */
  domainVersion(overrides?: CallOverrides): Promise<string>;

  /**
   * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
   * @param extension Either the global extension address or the deployed extension proxy address to enable
   */
  enableExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
   */
  generateDomainSeparator(overrides?: CallOverrides): Promise<string>;

  hasRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns true if `caller` has the Controller role granted
   */
  isController(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns true if `caller` has the Minter role granted
   */
  isMinter(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns the current token manager
   */
  manager(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Return the deployed extension proxy address given a global extension address. This function reverts if the given global extension has not been registered using registerExtension
   */
  proxyAddressForExtension(
    extension: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Register an extension providing the given global extension address. This will deploy a new ExtensionProxy contract to act as the extension proxy and register all function selectors the extension exposes. This will also invoke the initialize function on the extension proxy. Registering an extension automatically enables it for use. Registering an extension automatically grants any roles the extension requires to the address of the deployed extension proxy. See: IExtensionMetadata.requiredRoles()
   * @param extension The global extension address to register
   */
  registerExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
   * @param caller The address to remove the Controller role from
   */
  removeController(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
   * @param extension Either the global extension address or the deployed extension proxy address to remove
   */
  removeExtension(
    extension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
   * @param caller The address to remove the Minter role from
   */
  removeMinter(
    caller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
   * @param caller The address to remove the roleId from
   * @param roleId The role ID to remove from the caller address
   */
  removeRole(
    caller: PromiseOrValue<string>,
    roleId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tokenTransfer(
    _td: TransferDataStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
   * @param newOwner The address of the new owner
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
   * @param extension The global extension address to upgrade
   * @param newExtension The new global extension address to upgrade the extension to
   */
  upgradeExtension(
    extension: PromiseOrValue<string>,
    newExtension: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the TokenProxy logic contract. Can only be executed by the current manager address
   * Perform an upgrade on the proxy and replace the current logic contract with a new one. You must provide the new address of the logic contract and (optionally) some arbitrary data to pass to the logic contract's initialize function.
   * @param data Any arbitrary data, will be passed to the new logic contract's initialize function
   * @param logic The address of the new logic contract
   */
  upgradeTo(
    logic: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
   */
  tokenStandard(overrides?: CallOverrides): Promise<number>;

  callStatic: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled. You can use these addresses for direct interaction. Remember you can also interact with extensions through the TokenProxy.
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Return an array of all global extension addresses, regardless of if they are enabled or disabled. You cannot interact with these addresses. For user interaction you should use ExtendableTokenProxy.allExtensionProxies
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<string[]>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<string>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(overrides?: CallOverrides): Promise<string>;

    /**
     * Uses _domainName()
     * The current version for this contract. This is the domain version used in the domain seperator
     */
    domainVersion(overrides?: CallOverrides): Promise<string>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<string>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Return the deployed extension proxy address given a global extension address. This function reverts if the given global extension has not been registered using registerExtension
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Register an extension providing the given global extension address. This will deploy a new ExtensionProxy contract to act as the extension proxy and register all function selectors the extension exposes. This will also invoke the initialize function on the extension proxy. Registering an extension automatically enables it for use. Registering an extension automatically grants any roles the extension requires to the address of the deployed extension proxy. See: IExtensionMetadata.requiredRoles()
     * @param extension The global extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    tokenTransfer(
      _td: TransferDataStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the TokenProxy logic contract. Can only be executed by the current manager address
     * Perform an upgrade on the proxy and replace the current logic contract with a new one. You must provide the new address of the logic contract and (optionally) some arbitrary data to pass to the logic contract's initialize function.
     * @param data Any arbitrary data, will be passed to the new logic contract's initialize function
     * @param logic The address of the new logic contract
     */
    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<number>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "ExtensionUpgraded(address,address)"(
      extension?: PromiseOrValue<string> | null,
      newExtension?: PromiseOrValue<string> | null
    ): ExtensionUpgradedEventFilter;
    ExtensionUpgraded(
      extension?: PromiseOrValue<string> | null,
      newExtension?: PromiseOrValue<string> | null
    ): ExtensionUpgradedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "RoleAdded(address,bytes32)"(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleAddedEventFilter;
    RoleAdded(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleAddedEventFilter;

    "RoleRemoved(address,bytes32)"(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleRemovedEventFilter;
    RoleRemoved(
      caller?: PromiseOrValue<string> | null,
      roleId?: PromiseOrValue<BytesLike> | null
    ): RoleRemovedEventFilter;

    "Upgraded(address)"(
      logic?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(logic?: PromiseOrValue<string> | null): UpgradedEventFilter;
  };

  estimateGas: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Return an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled. You can use these addresses for direct interaction. Remember you can also interact with extensions through the TokenProxy.
     */
    allExtensionProxies(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return an array of all global extension addresses, regardless of if they are enabled or disabled. You cannot interact with these addresses. For user interaction you should use ExtendableTokenProxy.allExtensionProxies
     */
    allExtensionsRegistered(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Uses _domainName()
     * The current version for this contract. This is the domain version used in the domain seperator
     */
    domainVersion(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the deployed extension proxy address given a global extension address. This function reverts if the given global extension has not been registered using registerExtension
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Register an extension providing the given global extension address. This will deploy a new ExtensionProxy contract to act as the extension proxy and register all function selectors the extension exposes. This will also invoke the initialize function on the extension proxy. Registering an extension automatically enables it for use. Registering an extension automatically grants any roles the extension requires to the address of the deployed extension proxy. See: IExtensionMetadata.requiredRoles()
     * @param extension The global extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tokenTransfer(
      _td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade the TokenProxy logic contract. Can only be executed by the current manager address
     * Perform an upgrade on the proxy and replace the current logic contract with a new one. You must provide the new address of the logic contract and (optionally) some arbitrary data to pass to the logic contract's initialize function.
     * @param data Any arbitrary data, will be passed to the new logic contract's initialize function
     * @param logic The address of the new logic contract
     */
    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Grant the Controller role to `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to grant the Controller role to
     */
    addController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grant the Minter role to `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to grant the Minter role to
     */
    addMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Add a given roleId to the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to add the roleId to
     * @param roleId The role ID to assign to the caller address
     */
    addRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return an array of all deployed extension proxy addresses, regardless of if they are enabled or disabled. You can use these addresses for direct interaction. Remember you can also interact with extensions through the TokenProxy.
     */
    allExtensionProxies(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return an array of all global extension addresses, regardless of if they are enabled or disabled. You cannot interact with these addresses. For user interaction you should use ExtendableTokenProxy.allExtensionProxies
     */
    allExtensionsRegistered(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
     * @param addr Address for which the contract will implement the interface
     * @param interfaceHash keccak256 hash of the name of the interface
     */
    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This function is also invoked if transferOwnership is invoked when the current token owner is also the current manager.
     * Change the current token manager. Only the current token manager can set a new token manager.
     */
    changeManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Disable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Disabling the extension keeps the extension + storage live but simply disables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to disable
     */
    disableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Uses _domainName()
     * The domain name for this contract used in the domain seperator. This value will not change and will have a length greater than 0.
     */
    domainName(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * This call is cached by the chain-id and contract version. If these two values do not change then the cached domain seperator hash is returned. If these two values do change, then a new hash is generated and the cache is updated
     * Get the current domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id.
     */
    domainSeparator(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Uses _domainName()
     * The current version for this contract. This is the domain version used in the domain seperator
     */
    domainVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Enable the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Enabling the extension simply enables all registered functions and transfer events
     * @param extension Either the global extension address or the deployed extension proxy address to enable
     */
    enableExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Generate the domain seperator hash for this contract using the contract's domain name, current domain version and the current chain-id. This call bypasses the stored cache and will always represent the current domain seperator for this Contract's name + version + chain id.
     */
    generateDomainSeparator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `caller` has the Controller role granted
     */
    isController(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if `caller` has the Minter role granted
     */
    isMinter(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the current token manager
     */
    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the deployed extension proxy address given a global extension address. This function reverts if the given global extension has not been registered using registerExtension
     */
    proxyAddressForExtension(
      extension: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Register an extension providing the given global extension address. This will deploy a new ExtensionProxy contract to act as the extension proxy and register all function selectors the extension exposes. This will also invoke the initialize function on the extension proxy. Registering an extension automatically enables it for use. Registering an extension automatically grants any roles the extension requires to the address of the deployed extension proxy. See: IExtensionMetadata.requiredRoles()
     * @param extension The global extension address to register
     */
    registerExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the Controller role from `caller`. Only addresses with the Controller role granted may invoke this function
     * @param caller The address to remove the Controller role from
     */
    removeController(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the extension at the provided address. This may either be the global extension address or the deployed extension proxy address. Removing an extension deletes all data about the deployed extension proxy address and makes the extension's storage inaccessable forever.
     * @param extension Either the global extension address or the deployed extension proxy address to remove
     */
    removeExtension(
      extension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove the Minter role from `caller`. Only addresses with the Minter role granted may invoke this function
     * @param caller The address to remove the Minter role from
     */
    removeMinter(
      caller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Remove a given roleId from the provided caller address. Only the current token manager can invoke this function
     * @param caller The address to remove the roleId from
     * @param roleId The role ID to remove from the caller address
     */
    removeRole(
      caller: PromiseOrValue<string>,
      roleId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tokenTransfer(
      _td: TransferDataStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner. If the current owner is also the current manager, then the manager address is also updated to be the new owner
     * @param newOwner The address of the new owner
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade a registered extension at the given global extension address. This will perform an upgrade on the ExtensionProxy contract that was deployed during registration. The new global extension address must have the same deployer and package hash.
     * @param extension The global extension address to upgrade
     * @param newExtension The new global extension address to upgrade the extension to
     */
    upgradeExtension(
      extension: PromiseOrValue<string>,
      newExtension: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the TokenProxy logic contract. Can only be executed by the current manager address
     * Perform an upgrade on the proxy and replace the current logic contract with a new one. You must provide the new address of the logic contract and (optionally) some arbitrary data to pass to the logic contract's initialize function.
     * @param data Any arbitrary data, will be passed to the new logic contract's initialize function
     * @param logic The address of the new logic contract
     */
    upgradeTo(
      logic: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * A function to determine what token standard this token implements. This is a pure function, meaning the value should not change
     */
    tokenStandard(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
